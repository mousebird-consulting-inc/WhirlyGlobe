
/* Autogenerated. Do not edit. */

import Foundation
/**
    Datatypes and serializers for the sharing namespace
*/
public class Sharing {
    /**
        Who can access a shared link. The most open visibility is public. The default depends on many aspects, such as
        team and user preferences and shared folder settings.
    */
    public enum Visibility: CustomStringConvertible {
        /**
            Anyone who has received the link can access it. No login required.
        */
        case Public
        /**
            Only members of the same DfB (Dropbox for Business) team can access the link. Login is required.
        */
        case TeamOnly
        /**
            A link-specific password is required to access the link. Login is not required.
        */
        case Password
        /**
            Only members of the same DfB (Dropbox for Business) team who have the link-specific password can access the
            link.
        */
        case TeamAndPassword
        /**
            Only members of the shared folder containing the linked file can access the link. Login is required.
        */
        case SharedFolderOnly
        /**
            An unknown restriction is in place.
        */
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(VisibilitySerializer().serialize(self)))"
        }
    }
    public class VisibilitySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Visibility) -> JSON {
            switch value {
                case .Public:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("public")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .Password:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("password")
                    return .Dictionary(d)
                case .TeamAndPassword:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_and_password")
                    return .Dictionary(d)
                case .SharedFolderOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_folder_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> Visibility {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return Visibility.Public
                        case "team_only":
                            return Visibility.TeamOnly
                        case "password":
                            return Visibility.Password
                        case "team_and_password":
                            return Visibility.TeamAndPassword
                        case "shared_folder_only":
                            return Visibility.SharedFolderOnly
                        case "other":
                            return Visibility.Other
                        default:
                            return Visibility.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
    */
    public class LinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url : String
        /// Who can access the link.
        public let visibility : Sharing.Visibility
        /// Expiration time, if set. By default the link won't expire.
        public let expires : NSDate?
        public init(url: String, visibility: Sharing.Visibility, expires: NSDate? = nil) {
            stringValidator()(value: url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }
        public var description : String {
            return "\(prepareJSONForSerialization(LinkMetadataSerializer().serialize(self)))"
        }
    }
    public class LinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: LinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
                case let path as Sharing.PathLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("path")
                case let collection as Sharing.CollectionLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("collection")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> LinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "path":
                            return Sharing.PathLinkMetadataSerializer().deserialize(json)
                        case "collection":
                            return Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                            let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                            return LinkMetadata(url: url, visibility: visibility, expires: expires)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a path-based shared link.
    */
    public class PathLinkMetadata: Sharing.LinkMetadata {
        /// Path in user's Dropbox.
        public let path : String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: NSDate? = nil) {
            stringValidator()(value: path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(PathLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class PathLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PathLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "path": Serialization._StringSerializer.serialize(value.path),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PathLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a collection-based shared link.
    */
    public class CollectionLinkMetadata: Sharing.LinkMetadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(CollectionLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CollectionLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CollectionLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksArg struct
    */
    public class GetSharedLinksArg: CustomStringConvertible {
        /// See getSharedLinks description.
        public let path : String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksArgSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksArg {
            switch json {
                case .Dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .Null)
                    return GetSharedLinksArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksResult struct
    */
    public class GetSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        public let links : Array<Sharing.LinkMetadata>
        public init(links: Array<Sharing.LinkMetadata>) {
            self.links = links
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksResultSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksResult {
            switch json {
                case .Dictionary(let dict):
                    let links = ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .Null)
                    return GetSharedLinksResult(links: links)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksError union
    */
    public enum GetSharedLinksError: CustomStringConvertible {
        case Path(String?)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetSharedLinksError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["path"] ?? .Null)
                            return GetSharedLinksError.Path(v)
                        case "other":
                            return GetSharedLinksError.Other
                        default:
                            return GetSharedLinksError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Flag to indicate pending upload default (for linking to not-yet-existing paths).
    */
    public enum PendingUploadMode: CustomStringConvertible {
        /**
            Assume pending uploads are files.
        */
        case File
        /**
            Assume pending uploads are folders.
        */
        case Folder
        public var description : String {
            return "\(prepareJSONForSerialization(PendingUploadModeSerializer().serialize(self)))"
        }
    }
    public class PendingUploadModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PendingUploadMode) -> JSON {
            switch value {
                case .File:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file")
                    return .Dictionary(d)
                case .Folder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PendingUploadMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return PendingUploadMode.File
                        case "folder":
                            return PendingUploadMode.Folder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The CreateSharedLinkArg struct
    */
    public class CreateSharedLinkArg: CustomStringConvertible {
        /// The path to share.
        public let path : String
        /// Whether to return a shortened URL.
        public let shortUrl : Bool
        /// If it's okay to share a path that does not yet exist, set this to either 'file' or 'folder' to indicate
        /// whether to assume it's a file or folder.
        public let pendingUpload : Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(value: path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkArgSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "short_url": Serialization._BoolSerializer.serialize(value.shortUrl),
            "pending_upload": NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateSharedLinkArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let shortUrl = Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .Null)
                    let pendingUpload = NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .Null)
                    return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The CreateSharedLinkError union
    */
    public enum CreateSharedLinkError: CustomStringConvertible {
        case Path(Files.LookupError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CreateSharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return CreateSharedLinkError.Path(v)
                        case "other":
                            return CreateSharedLinkError.Other
                        default:
                            return CreateSharedLinkError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RevokeSharedLinkArg struct
    */
    public class RevokeSharedLinkArg: CustomStringConvertible {
        /// URL of the shared link.
        public let url : String
        public init(url: String) {
            stringValidator()(value: url)
            self.url = url
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RevokeSharedLinkArgSerializer().serialize(self)))"
        }
    }
    public class RevokeSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeSharedLinkArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeSharedLinkArg {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    return RevokeSharedLinkArg(url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RevokeSharedLinkError union
    */
    public enum RevokeSharedLinkError: CustomStringConvertible {
        /**
            Shared link is malformed.
        */
        case SharedLinkMalformed
        /**
            Shared link not found.
        */
        case SharedLinkNotFound
        /**
            Shared link access denied.
        */
        case SharedLinkAccessDenied
        /**
            An unspecified error.
        */
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RevokeSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeSharedLinkError) -> JSON {
            switch value {
                case .SharedLinkMalformed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_link_malformed")
                    return .Dictionary(d)
                case .SharedLinkNotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_link_not_found")
                    return .Dictionary(d)
                case .SharedLinkAccessDenied:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_link_access_denied")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeSharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_malformed":
                            return RevokeSharedLinkError.SharedLinkMalformed
                        case "shared_link_not_found":
                            return RevokeSharedLinkError.SharedLinkNotFound
                        case "shared_link_access_denied":
                            return RevokeSharedLinkError.SharedLinkAccessDenied
                        case "other":
                            return RevokeSharedLinkError.Other
                        default:
                            return RevokeSharedLinkError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Defines the access levels for collaborators.
    */
    public enum AccessLevel: CustomStringConvertible {
        /**
            The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
            set the folder's policies using updateFolderPolicy.
        */
        case Owner
        /**
            The collaborator can both view and edit the shared folder.
        */
        case Editor
        /**
            The collaborator can only view the shared folder.
        */
        case Viewer
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(AccessLevelSerializer().serialize(self)))"
        }
    }
    public class AccessLevelSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AccessLevel) -> JSON {
            switch value {
                case .Owner:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
                case .Editor:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("editor")
                    return .Dictionary(d)
                case .Viewer:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("viewer")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AccessLevel {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AccessLevel.Owner
                        case "editor":
                            return AccessLevel.Editor
                        case "viewer":
                            return AccessLevel.Viewer
                        case "other":
                            return AccessLevel.Other
                        default:
                            return AccessLevel.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        A set of policies governing membership and privileges for a shared folder.
    */
    public class FolderPolicy: CustomStringConvertible {
        /// Who can be a member of this shared folder. Only set if the user is a member of a team.
        public let memberPolicy : Sharing.MemberPolicy?
        /// Who can add and remove members from this shared folder.
        public let aclUpdatePolicy : Sharing.AclUpdatePolicy
        /// Who links can be shared with.
        public let sharedLinkPolicy : Sharing.SharedLinkPolicy
        public init(aclUpdatePolicy: Sharing.AclUpdatePolicy, sharedLinkPolicy: Sharing.SharedLinkPolicy, memberPolicy: Sharing.MemberPolicy? = nil) {
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(FolderPolicySerializer().serialize(self)))"
        }
    }
    public class FolderPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderPolicy) -> JSON {
            let output = [ 
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderPolicy {
            switch json {
                case .Dictionary(let dict):
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .Null)
                    return FolderPolicy(aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, memberPolicy: memberPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
    */
    public enum MemberPolicy: CustomStringConvertible {
        /**
            Only a teammate can become a member.
        */
        case Team
        /**
            Anyone can become a member.
        */
        case Anyone
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(MemberPolicySerializer().serialize(self)))"
        }
    }
    public class MemberPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberPolicy) -> JSON {
            switch value {
                case .Team:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team")
                    return .Dictionary(d)
                case .Anyone:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("anyone")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberPolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team":
                            return MemberPolicy.Team
                        case "anyone":
                            return MemberPolicy.Anyone
                        case "other":
                            return MemberPolicy.Other
                        default:
                            return MemberPolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Policy governing who can change a shared folder's access control list (ACL). In other words, who can add,
        remove, or change the privileges of members.
    */
    public enum AclUpdatePolicy: CustomStringConvertible {
        /**
            Only the owner can update the ACL.
        */
        case Owner
        /**
            Any editor can update the ACL. This may be further restricted to editors on the same team.
        */
        case Editors
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(AclUpdatePolicySerializer().serialize(self)))"
        }
    }
    public class AclUpdatePolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AclUpdatePolicy) -> JSON {
            switch value {
                case .Owner:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
                case .Editors:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("editors")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AclUpdatePolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AclUpdatePolicy.Owner
                        case "editors":
                            return AclUpdatePolicy.Editors
                        case "other":
                            return AclUpdatePolicy.Other
                        default:
                            return AclUpdatePolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Policy governing who can view shared links.
    */
    public enum SharedLinkPolicy: CustomStringConvertible {
        /**
            Links can be shared with anyone.
        */
        case Anyone
        /**
            Links can only be shared among members of the shared folder.
        */
        case Members
        /**
            An unknown shared link policy.
        */
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedLinkPolicySerializer().serialize(self)))"
        }
    }
    public class SharedLinkPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkPolicy) -> JSON {
            switch value {
                case .Anyone:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("anyone")
                    return .Dictionary(d)
                case .Members:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("members")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkPolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "anyone":
                            return SharedLinkPolicy.Anyone
                        case "members":
                            return SharedLinkPolicy.Members
                        case "other":
                            return SharedLinkPolicy.Other
                        default:
                            return SharedLinkPolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The information about a member of the shared folder.
    */
    public class MembershipInfo: CustomStringConvertible {
        /// The access type for this member.
        public let accessType : Sharing.AccessLevel
        public init(accessType: Sharing.AccessLevel) {
            self.accessType = accessType
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MembershipInfoSerializer().serialize(self)))"
        }
    }
    public class MembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    return MembershipInfo(accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Basic information about a user. Use usersAccount and usersAccountBatch` to obtain more detailed information.
    */
    public class UserInfo: CustomStringConvertible {
        /// The account ID of the user.
        public let accountId : String
        /// If the user is in the same team as current user.
        public let sameTeam : Bool
        /// The team member ID of the shared folder member. Only present if sameTeam is true.
        public let teamMemberId : String?
        public init(accountId: String, sameTeam: Bool, teamMemberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(value: accountId)
            self.accountId = accountId
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(value: teamMemberId)
            self.teamMemberId = teamMemberId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    public class UserInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserInfo) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserInfo {
            switch json {
                case .Dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .Null)
                    return UserInfo(accountId: accountId, sameTeam: sameTeam, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a user member of the shared folder.
    */
    public class UserMembershipInfo: Sharing.MembershipInfo {
        /// The account information for the membership user.
        public let user : Sharing.UserInfo
        public init(accessType: Sharing.AccessLevel, user: Sharing.UserInfo) {
            self.user = user
            super.init(accessType: accessType)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(UserMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class UserMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .Null)
                    return UserMembershipInfo(accessType: accessType, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a non-Dropbox user invited to join a shared folder.
    */
    public enum InviteeInfo: CustomStringConvertible {
        /**
            E-mail address of invited user.
        */
        case Email(String)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(InviteeInfoSerializer().serialize(self)))"
        }
    }
    public class InviteeInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: InviteeInfo) -> JSON {
            switch value {
                case .Email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("email")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> InviteeInfo {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .Null)
                            return InviteeInfo.Email(v)
                        case "other":
                            return InviteeInfo.Other
                        default:
                            return InviteeInfo.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The information about a non-Dropbox member invited to join a shared folder.
    */
    public class InviteeMembershipInfo: Sharing.MembershipInfo {
        /// The information for the invited user.
        public let invitee : Sharing.InviteeInfo
        public init(accessType: Sharing.AccessLevel, invitee: Sharing.InviteeInfo) {
            self.invitee = invitee
            super.init(accessType: accessType)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(InviteeMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class InviteeMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: InviteeMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "invitee": Sharing.InviteeInfoSerializer().serialize(value.invitee),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> InviteeMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let invitee = Sharing.InviteeInfoSerializer().deserialize(dict["invitee"] ?? .Null)
                    return InviteeMembershipInfo(accessType: accessType, invitee: invitee)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a group. Groups is a way to manage a list of users  who need same access permission to the
        shared folder.
    */
    public class GroupInfo: Team.GroupSummary {
        /// If the group is owned by the current user's team.
        public let sameTeam : Bool
        public init(groupName: String, groupId: String, memberCount: UInt32, sameTeam: Bool, groupExternalId: String? = nil) {
            self.sameTeam = sameTeam
            super.init(groupName: groupName, groupId: groupId, memberCount: memberCount, groupExternalId: groupExternalId)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(GroupInfoSerializer().serialize(self)))"
        }
    }
    public class GroupInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupInfo) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "member_count": Serialization._UInt32Serializer.serialize(value.memberCount),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupInfo {
            switch json {
                case .Dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .Null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .Null)
                    let memberCount = Serialization._UInt32Serializer.deserialize(dict["member_count"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .Null)
                    return GroupInfo(groupName: groupName, groupId: groupId, memberCount: memberCount, sameTeam: sameTeam, groupExternalId: groupExternalId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a group member of the shared folder.
    */
    public class GroupMembershipInfo: Sharing.MembershipInfo {
        /// The information about the membership group.
        public let group : Sharing.GroupInfo
        public init(accessType: Sharing.AccessLevel, group: Sharing.GroupInfo) {
            self.group = group
            super.init(accessType: accessType)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(GroupMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class GroupMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "group": Sharing.GroupInfoSerializer().serialize(value.group),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let group = Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .Null)
                    return GroupMembershipInfo(accessType: accessType, group: group)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The base type for shared folder metadata.
    */
    public class SharedFolderMetadata: CustomStringConvertible {
        /// The lower-cased full path of this shared folder. Absent for unmounted folders.
        public let pathLower : String?
        /// The name of the this shared folder.
        public let name : String
        /// The ID of the shared folder.
        public let id : String
        /// The current user's access level for this shared folder.
        public let accessType : Sharing.AccessLevel
        /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
        public let isTeamFolder : Bool
        /// Policies governing this shared folder.
        public let policy : Sharing.FolderPolicy
        public init(name: String, id: String, accessType: Sharing.AccessLevel, isTeamFolder: Bool, policy: Sharing.FolderPolicy, pathLower: String? = nil) {
            nullableValidator(stringValidator())(value: pathLower)
            self.pathLower = pathLower
            stringValidator()(value: name)
            self.name = name
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: id)
            self.id = id
            self.accessType = accessType
            self.isTeamFolder = isTeamFolder
            self.policy = policy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMetadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            switch value {
                case let basic as Sharing.BasicSharedFolderMetadata:
                    for (k,v) in Serialization.getFields(Sharing.BasicSharedFolderMetadataSerializer().serialize(basic)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("basic")
                case let full as Sharing.FullSharedFolderMetadata:
                    for (k,v) in Serialization.getFields(Sharing.FullSharedFolderMetadataSerializer().serialize(full)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("full")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "basic":
                            return Sharing.BasicSharedFolderMetadataSerializer().deserialize(json)
                        case "full":
                            return Sharing.FullSharedFolderMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The metadata which includes basic information about the shared folder.
    */
    public class BasicSharedFolderMetadata: Sharing.SharedFolderMetadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(BasicSharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class BasicSharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: BasicSharedFolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> BasicSharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .Null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    return BasicSharedFolderMetadata(name: name, id: id, accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The full metadata for the shared folder which includes user and group membership.
    */
    public class FullSharedFolderMetadata: Sharing.SharedFolderMetadata {
        /// The list of user members of the shared folder.
        public let membership : Array<Sharing.UserMembershipInfo>
        /// The list of group members of the shared folder.
        public let groups : Array<Sharing.GroupMembershipInfo>
        /// The list of non-Dropbox users invited to join the shared folder.
        public let invitees : Array<Sharing.InviteeMembershipInfo>
        public init(name: String, id: String, accessType: Sharing.AccessLevel, isTeamFolder: Bool, policy: Sharing.FolderPolicy, membership: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, pathLower: String? = nil) {
            self.membership = membership
            self.groups = groups
            self.invitees = invitees
            super.init(name: name, id: id, accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FullSharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FullSharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FullSharedFolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "membership": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.membership),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FullSharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .Null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .Null)
                    let membership = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["membership"] ?? .Null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .Null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    return FullSharedFolderMetadata(name: name, id: id, accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, membership: membership, groups: groups, invitees: invitees, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        There is an error accessing the shared folder.
    */
    public enum SharedFolderAccessError: CustomStringConvertible {
        /**
            This shared folder ID is invalid.
        */
        case InvalidId
        /**
            The user is not a member of the shared folder thus cannot access it.
        */
        case NotMember
        /**
            The current user does not have sufficient privileges to perform the desired action.
        */
        case NoPermission
        /**
            The current account's e-mail address is unverified.
        */
        case EmailUnverified
        /**
            The current user cannot perform this action on a team shared folder.
        */
        case TeamFolder
        /**
            The shared folder is unmounted.
        */
        case Unmounted
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderAccessErrorSerializer().serialize(self)))"
        }
    }
    public class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderAccessError) -> JSON {
            switch value {
                case .InvalidId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_id")
                    return .Dictionary(d)
                case .NotMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_member")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .EmailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .Unmounted:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unmounted")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedFolderAccessError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_id":
                            return SharedFolderAccessError.InvalidId
                        case "not_member":
                            return SharedFolderAccessError.NotMember
                        case "no_permission":
                            return SharedFolderAccessError.NoPermission
                        case "email_unverified":
                            return SharedFolderAccessError.EmailUnverified
                        case "team_folder":
                            return SharedFolderAccessError.TeamFolder
                        case "unmounted":
                            return SharedFolderAccessError.Unmounted
                        case "other":
                            return SharedFolderAccessError.Other
                        default:
                            return SharedFolderAccessError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The GetMetadataArgs struct
    */
    public class GetMetadataArgs: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// If true, user and group membership included in the response.
        public let includeMembership : Bool
        public init(sharedFolderId: String, includeMembership: Bool = true) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.includeMembership = includeMembership
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgsSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "include_membership": Serialization._BoolSerializer.serialize(value.includeMembership),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMetadataArgs {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let includeMembership = Serialization._BoolSerializer.deserialize(dict["include_membership"] ?? .Null)
                    return GetMetadataArgs(sharedFolderId: sharedFolderId, includeMembership: includeMembership)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFoldersArgs struct
    */
    public class ListFoldersArgs: CustomStringConvertible {
        /// If include user and group membership information in the response.
        public let includeMembership : Bool
        public init(includeMembership: Bool = false) {
            self.includeMembership = includeMembership
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFoldersArgsSerializer().serialize(self)))"
        }
    }
    public class ListFoldersArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersArgs) -> JSON {
            let output = [ 
            "include_membership": Serialization._BoolSerializer.serialize(value.includeMembership),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFoldersArgs {
            switch json {
                case .Dictionary(let dict):
                    let includeMembership = Serialization._BoolSerializer.deserialize(dict["include_membership"] ?? .Null)
                    return ListFoldersArgs(includeMembership: includeMembership)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Result for listFolders. Unmounted shared folders can be identified by the absence of pathLower in
        SharedFolderMetadata.
    */
    public class ListFoldersResult: CustomStringConvertible {
        /// List of all shared folders the authenticated user has access to.
        public let entries : Array<Sharing.SharedFolderMetadata>
        public init(entries: Array<Sharing.SharedFolderMetadata>) {
            self.entries = entries
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFoldersResultSerializer().serialize(self)))"
        }
    }
    public class ListFoldersResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFoldersResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    return ListFoldersResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ShareFolderArg struct
    */
    public class ShareFolderArg: CustomStringConvertible {
        /// The path to the folder to share. If it does not exist, then a new one is created.
        public let path : String
        /// Who can be a member of this shared folder.
        public let memberPolicy : Sharing.MemberPolicy
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy : Sharing.AclUpdatePolicy
        /// The policy to apply to shared links created for content inside this shared folder.
        public let sharedLinkPolicy : Sharing.SharedLinkPolicy
        /// Whether to force the share to happen asynchronously.
        public let forceAsync : Bool
        public init(path: String, memberPolicy: Sharing.MemberPolicy = .Anyone, aclUpdatePolicy: Sharing.AclUpdatePolicy = .Owner, sharedLinkPolicy: Sharing.SharedLinkPolicy = .Anyone, forceAsync: Bool = false) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.forceAsync = forceAsync
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderArgSerializer().serialize(self)))"
        }
    }
    public class ShareFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "member_policy": Sharing.MemberPolicySerializer().serialize(value.memberPolicy),
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ShareFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let memberPolicy = Sharing.MemberPolicySerializer().deserialize(dict["member_policy"] ?? .Null)
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .Null)
                    return ShareFolderArg(path: path, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ShareFolderError union
    */
    public enum ShareFolderError: CustomStringConvertible {
        /**
            The current account's e-mail address is unverified.
        */
        case EmailUnverified
        /**
            path in ShareFolderArg is invalid.
        */
        case BadPath(Sharing.SharePathError)
        /**
            Team policy is more restrictive than memberPolicy in ShareFolderArg.
        */
        case TeamPolicyDisallowsMemberPolicy
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ShareFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderError) -> JSON {
            switch value {
                case .EmailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .BadPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("bad_path")
                    return .Dictionary(d)
                case .TeamPolicyDisallowsMemberPolicy:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_policy_disallows_member_policy")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderError.EmailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .Null)
                            return ShareFolderError.BadPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderError.TeamPolicyDisallowsMemberPolicy
                        case "other":
                            return ShareFolderError.Other
                        default:
                            return ShareFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SharePathError union
    */
    public enum SharePathError: CustomStringConvertible {
        /**
            A file is at the specified path.
        */
        case IsFile
        /**
            We do not support sharing a folder inside a shared folder.
        */
        case InsideSharedFolder
        /**
            We do not support shared folders that contain shared folders.
        */
        case ContainsSharedFolder
        /**
            We do not support sharing an app folder.
        */
        case IsAppFolder
        /**
            We do not support sharing a folder inside an app folder.
        */
        case InsideAppFolder
        /**
            Folder is already shared.
        */
        case AlreadyShared
        /**
            Path is not valid.
        */
        case InvalidPath
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SharePathErrorSerializer().serialize(self)))"
        }
    }
    public class SharePathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharePathError) -> JSON {
            switch value {
                case .IsFile:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_file")
                    return .Dictionary(d)
                case .InsideSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("inside_shared_folder")
                    return .Dictionary(d)
                case .ContainsSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("contains_shared_folder")
                    return .Dictionary(d)
                case .IsAppFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_app_folder")
                    return .Dictionary(d)
                case .InsideAppFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("inside_app_folder")
                    return .Dictionary(d)
                case .AlreadyShared:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("already_shared")
                    return .Dictionary(d)
                case .InvalidPath:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharePathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "is_file":
                            return SharePathError.IsFile
                        case "inside_shared_folder":
                            return SharePathError.InsideSharedFolder
                        case "contains_shared_folder":
                            return SharePathError.ContainsSharedFolder
                        case "is_app_folder":
                            return SharePathError.IsAppFolder
                        case "inside_app_folder":
                            return SharePathError.InsideAppFolder
                        case "already_shared":
                            return SharePathError.AlreadyShared
                        case "invalid_path":
                            return SharePathError.InvalidPath
                        case "other":
                            return SharePathError.Other
                        default:
                            return SharePathError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        If any of the policy's are unset, then they retain their current setting.
    */
    public class UpdateFolderPolicyArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// Who can be a member of this shared folder. Only set this if the current user is on a team.
        public let memberPolicy : Sharing.MemberPolicy?
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy : Sharing.AclUpdatePolicy?
        /// The policy to apply to shared links created for content inside this shared folder.
        public let sharedLinkPolicy : Sharing.SharedLinkPolicy?
        public init(sharedFolderId: String, memberPolicy: Sharing.MemberPolicy? = nil, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderPolicyArgSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderPolicyArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderPolicyArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdateFolderPolicyArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .Null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .Null)
                    return UpdateFolderPolicyArg(sharedFolderId: sharedFolderId, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UpdateFolderPolicyError union
    */
    public enum UpdateFolderPolicyError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
        */
        case NotOnTeam
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderPolicyErrorSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderPolicyErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderPolicyError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .NotOnTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_on_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UpdateFolderPolicyError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UpdateFolderPolicyError.AccessError(v)
                        case "not_on_team":
                            return UpdateFolderPolicyError.NotOnTeam
                        case "other":
                            return UpdateFolderPolicyError.Other
                        default:
                            return UpdateFolderPolicyError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UnshareFolderArg struct
    */
    public class UnshareFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
        /// will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.
        public let leaveACopy : Bool
        public init(sharedFolderId: String, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UnshareFolderArgSerializer().serialize(self)))"
        }
    }
    public class UnshareFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UnshareFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .Null)
                    return UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UnshareFolderError union
    */
    public enum UnshareFolderError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UnshareFolderErrorSerializer().serialize(self)))"
        }
    }
    public class UnshareFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UnshareFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UnshareFolderError.AccessError(v)
                        case "other":
                            return UnshareFolderError.Other
                        default:
                            return UnshareFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The TransferFolderArg struct
    */
    public class TransferFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// A account or team member ID to transfer ownership to.
        public let toDropboxId : String
        public init(sharedFolderId: String, toDropboxId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator(minLength: 1)(value: toDropboxId)
            self.toDropboxId = toDropboxId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(TransferFolderArgSerializer().serialize(self)))"
        }
    }
    public class TransferFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TransferFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "to_dropbox_id": Serialization._StringSerializer.serialize(value.toDropboxId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TransferFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let toDropboxId = Serialization._StringSerializer.deserialize(dict["to_dropbox_id"] ?? .Null)
                    return TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The TransferFolderError union
    */
    public enum TransferFolderError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        case InvalidDropboxId
        case NoPermission
        /**
            The new designated owner is not currently a member of the shared folder.
        */
        case NewOwnerNotMember
        /**
            The new desginated owner does not have the shared folder mounted.
        */
        case NewOwnerUnmounted
        /**
            The new designated owner's e-mail address is unverified.
        */
        case NewOwnerEmailUnverified
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(TransferFolderErrorSerializer().serialize(self)))"
        }
    }
    public class TransferFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TransferFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .NewOwnerNotMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("new_owner_not_member")
                    return .Dictionary(d)
                case .NewOwnerUnmounted:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("new_owner_unmounted")
                    return .Dictionary(d)
                case .NewOwnerEmailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("new_owner_email_unverified")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> TransferFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return TransferFolderError.AccessError(v)
                        case "invalid_dropbox_id":
                            return TransferFolderError.InvalidDropboxId
                        case "no_permission":
                            return TransferFolderError.NoPermission
                        case "new_owner_not_member":
                            return TransferFolderError.NewOwnerNotMember
                        case "new_owner_unmounted":
                            return TransferFolderError.NewOwnerUnmounted
                        case "new_owner_email_unverified":
                            return TransferFolderError.NewOwnerEmailUnverified
                        case "other":
                            return TransferFolderError.Other
                        default:
                            return TransferFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UnmountFolderArg struct
    */
    public class UnmountFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UnmountFolderArgSerializer().serialize(self)))"
        }
    }
    public class UnmountFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnmountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UnmountFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    return UnmountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UnmountFolderError union
    */
    public enum UnmountFolderError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UnmountFolderErrorSerializer().serialize(self)))"
        }
    }
    public class UnmountFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnmountFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UnmountFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UnmountFolderError.AccessError(v)
                        case "other":
                            return UnmountFolderError.Other
                        default:
                            return UnmountFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The MountFolderArg struct
    */
    public class MountFolderArg: CustomStringConvertible {
        /// The ID of the shared folder to mount.
        public let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MountFolderArgSerializer().serialize(self)))"
        }
    }
    public class MountFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MountFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    return MountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The MountFolderError union
    */
    public enum MountFolderError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            Mounting would cause a shared folder to be inside another, which is disallowed.
        */
        case InsideSharedFolder
        /**
            The current user does not have enough space to mount the shared folder.
        */
        case InsufficientQuota
        /**
            The shared folder is already mounted.
        */
        case AlreadyMounted
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(MountFolderErrorSerializer().serialize(self)))"
        }
    }
    public class MountFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MountFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InsideSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("inside_shared_folder")
                    return .Dictionary(d)
                case .InsufficientQuota:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("insufficient_quota")
                    return .Dictionary(d)
                case .AlreadyMounted:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("already_mounted")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MountFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return MountFolderError.AccessError(v)
                        case "inside_shared_folder":
                            return MountFolderError.InsideSharedFolder
                        case "insufficient_quota":
                            return MountFolderError.InsufficientQuota
                        case "already_mounted":
                            return MountFolderError.AlreadyMounted
                        case "other":
                            return MountFolderError.Other
                        default:
                            return MountFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddFolderMemberArg struct
    */
    public class AddFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// The intended list of members to add.  Added members will receive invites to join the shared folder.
        public let members : Array<Sharing.AddMember>
        /// Whether added members should be notified via email and device notifications of their invite.
        public let quiet : Bool
        /// Optional message to display to added members in their invitation.
        public let customMessage : String?
        public init(sharedFolderId: String, members: Array<Sharing.AddMember>, quiet: Bool = false, customMessage: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.members = members
            self.quiet = quiet
            nullableValidator(stringValidator(minLength: 1))(value: customMessage)
            self.customMessage = customMessage
        }
        public var description : String {
            return "\(prepareJSONForSerialization(AddFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class AddFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "members": ArraySerializer(Sharing.AddMemberSerializer()).serialize(value.members),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let members = ArraySerializer(Sharing.AddMemberSerializer()).deserialize(dict["members"] ?? .Null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .Null)
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .Null)
                    return AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The member and type of access the member should have when added to a shared folder.
    */
    public class AddMember: CustomStringConvertible {
        /// The member to add to the shared folder.
        public let member : Sharing.MemberSelector
        /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
        public let accessLevel : Sharing.AccessLevel
        public init(member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel = .Viewer) {
            self.member = member
            self.accessLevel = accessLevel
        }
        public var description : String {
            return "\(prepareJSONForSerialization(AddMemberSerializer().serialize(self)))"
        }
    }
    public class AddMemberSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddMember) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddMember {
            switch json {
                case .Dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .Null)
                    return AddMember(member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Includes different ways to identify a member to add to a shared folder.
    */
    public enum MemberSelector: CustomStringConvertible {
        /**
            Dropbox account, team member, or group ID of member to add.
        */
        case DropboxId(String)
        /**
            E-mail address of member to add.
        */
        case Email(String)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(MemberSelectorSerializer().serialize(self)))"
        }
    }
    public class MemberSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberSelector) -> JSON {
            switch value {
                case .DropboxId(let arg):
                    var d = ["dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("dropbox_id")
                    return .Dictionary(d)
                case .Email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("email")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberSelector {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["dropbox_id"] ?? .Null)
                            return MemberSelector.DropboxId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .Null)
                            return MemberSelector.Email(v)
                        case "other":
                            return MemberSelector.Other
                        default:
                            return MemberSelector.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddFolderMemberError union
    */
    public enum AddFolderMemberError: CustomStringConvertible {
        /**
            Unable to access shared folder.
        */
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            The current account's e-mail address is unverified.
        */
        case EmailUnverified
        /**
            members in AddFolderMemberArg contains a bad invitation recipient.
        */
        case BadMember(Sharing.AddMemberSelectorError)
        /**
            The current account does not have permission to perform this action.
        */
        case NoPermission
        /**
            Your team policy does not allow sharing outside of the team.
        */
        case CantShareOutsideTeam
        /**
            The value is the member limit that was reached.
        */
        case TooManyMembers(UInt64)
        /**
            The value is the pending invite limit that was reached.
        */
        case TooManyPendingInvites(UInt64)
        /**
            The current user's account doesn't support this action. An example of this is when adding a read-only
            member. This action can only be performed by users that have upgraded to a Pro or Business plan.
        */
        case InsufficientPlan
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(AddFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class AddFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .EmailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .BadMember(let arg):
                    var d = ["bad_member": Sharing.AddMemberSelectorErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("bad_member")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .CantShareOutsideTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("cant_share_outside_team")
                    return .Dictionary(d)
                case .TooManyMembers(let arg):
                    var d = ["too_many_members": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .Str("too_many_members")
                    return .Dictionary(d)
                case .TooManyPendingInvites(let arg):
                    var d = ["too_many_pending_invites": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .Str("too_many_pending_invites")
                    return .Dictionary(d)
                case .InsufficientPlan:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("insufficient_plan")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AddFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return AddFolderMemberError.AccessError(v)
                        case "email_unverified":
                            return AddFolderMemberError.EmailUnverified
                        case "bad_member":
                            let v = Sharing.AddMemberSelectorErrorSerializer().deserialize(d["bad_member"] ?? .Null)
                            return AddFolderMemberError.BadMember(v)
                        case "no_permission":
                            return AddFolderMemberError.NoPermission
                        case "cant_share_outside_team":
                            return AddFolderMemberError.CantShareOutsideTeam
                        case "too_many_members":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_members"] ?? .Null)
                            return AddFolderMemberError.TooManyMembers(v)
                        case "too_many_pending_invites":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_pending_invites"] ?? .Null)
                            return AddFolderMemberError.TooManyPendingInvites(v)
                        case "insufficient_plan":
                            return AddFolderMemberError.InsufficientPlan
                        case "other":
                            return AddFolderMemberError.Other
                        default:
                            return AddFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddMemberSelectorError union
    */
    public enum AddMemberSelectorError: CustomStringConvertible {
        /**
            The value is the ID that could not be identified.
        */
        case InvalidDropboxId(String)
        /**
            The value is the e-email address that is malformed.
        */
        case InvalidEmail(String)
        /**
            The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by
            e-mail address instead of by their Dropbox ID.
        */
        case UnverifiedDropboxId(String)
        /**
            At least one of the specified groups in members in AddFolderMemberArg is deleted.
        */
        case GroupDeleted
        /**
            Sharing to a group that is not on the current account's team.
        */
        case GroupNotOnTeam
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(AddMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class AddMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddMemberSelectorError) -> JSON {
            switch value {
                case .InvalidDropboxId(let arg):
                    var d = ["invalid_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .InvalidEmail(let arg):
                    var d = ["invalid_email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("invalid_email")
                    return .Dictionary(d)
                case .UnverifiedDropboxId(let arg):
                    var d = ["unverified_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("unverified_dropbox_id")
                    return .Dictionary(d)
                case .GroupDeleted:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("group_deleted")
                    return .Dictionary(d)
                case .GroupNotOnTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("group_not_on_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AddMemberSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_dropbox_id"] ?? .Null)
                            return AddMemberSelectorError.InvalidDropboxId(v)
                        case "invalid_email":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_email"] ?? .Null)
                            return AddMemberSelectorError.InvalidEmail(v)
                        case "unverified_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["unverified_dropbox_id"] ?? .Null)
                            return AddMemberSelectorError.UnverifiedDropboxId(v)
                        case "group_deleted":
                            return AddMemberSelectorError.GroupDeleted
                        case "group_not_on_team":
                            return AddMemberSelectorError.GroupNotOnTeam
                        case "other":
                            return AddMemberSelectorError.Other
                        default:
                            return AddMemberSelectorError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ShareFolderJobStatus union
    */
    public enum ShareFolderJobStatus: CustomStringConvertible {
        /**
            The share job has finished. The value is the metadata for the folder.
        */
        case Complete(Sharing.FullSharedFolderMetadata)
        case Failed(Sharing.ShareFolderError)
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderJobStatusSerializer().serialize(self)))"
        }
    }
    public class ShareFolderJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderJobStatus) -> JSON {
            switch value {
                case .Complete(let arg):
                    var d = Serialization.getFields(Sharing.FullSharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Sharing.ShareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderJobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            let v = Sharing.FullSharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderJobStatus.Complete(v)
                        case "failed":
                            let v = Sharing.ShareFolderErrorSerializer().deserialize(d["failed"] ?? .Null)
                            return ShareFolderJobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ShareFolderLaunch union
    */
    public enum ShareFolderLaunch: CustomStringConvertible {
        case Complete(Sharing.FullSharedFolderMetadata)
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderLaunchSerializer().serialize(self)))"
        }
    }
    public class ShareFolderLaunchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderLaunch) -> JSON {
            switch value {
                case .Complete(let arg):
                    var d = Serialization.getFields(Sharing.FullSharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderLaunch {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            let v = Sharing.FullSharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderLaunch.Complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The JobStatus union
    */
    public enum JobStatus: CustomStringConvertible {
        /**
            The asynchronous job has finished.
        */
        case Complete
        /**
            The asynchronous job returned an error.
        */
        case Failed(Sharing.JobError)
        public var description : String {
            return "\(prepareJSONForSerialization(JobStatusSerializer().serialize(self)))"
        }
    }
    public class JobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: JobStatus) -> JSON {
            switch value {
                case .Complete:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Sharing.JobErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> JobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            return JobStatus.Complete
                        case "failed":
                            let v = Sharing.JobErrorSerializer().deserialize(d["failed"] ?? .Null)
                            return JobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SharedFolderMemberError union
    */
    public enum SharedFolderMemberError: CustomStringConvertible {
        /**
            The target dropbox_id is invalid.
        */
        case InvalidDropboxId
        /**
            The target dropbox_id is not a member of the shared folder.
        */
        case NotAMember
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMemberError) -> JSON {
            switch value {
                case .InvalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NotAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_a_member")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            return SharedFolderMemberError.InvalidDropboxId
                        case "not_a_member":
                            return SharedFolderMemberError.NotAMember
                        case "other":
                            return SharedFolderMemberError.Other
                        default:
                            return SharedFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The JobError union
    */
    public enum JobError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        case MemberError(Sharing.SharedFolderMemberError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(JobErrorSerializer().serialize(self)))"
        }
    }
    public class JobErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: JobError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .MemberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("member_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> JobError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return JobError.AccessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .Null)
                            return JobError.MemberError(v)
                        case "other":
                            return JobError.Other
                        default:
                            return JobError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RemoveFolderMemberArg struct
    */
    public class RemoveFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// The member to remove from the folder. Only the dropboxId in MemberSelector may be set at this time.
        public let member : Sharing.MemberSelector
        /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
        /// Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group.
        public let leaveACopy : Bool
        public init(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.leaveACopy = leaveACopy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RemoveFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class RemoveFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RemoveFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .Null)
                    return RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RemoveFolderMemberError union
    */
    public enum RemoveFolderMemberError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            The target dropboxId in MemberSelector is invalid.
        */
        case InvalidDropboxId
        /**
            The target dropboxId in MemberSelector is not a member of the shared folder.
        */
        case NotAMember
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RemoveFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class RemoveFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NotAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_a_member")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RemoveFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RemoveFolderMemberError.AccessError(v)
                        case "invalid_dropbox_id":
                            return RemoveFolderMemberError.InvalidDropboxId
                        case "not_a_member":
                            return RemoveFolderMemberError.NotAMember
                        case "other":
                            return RemoveFolderMemberError.Other
                        default:
                            return RemoveFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UpdateFolderMemberArg struct
    */
    public class UpdateFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
        public let member : Sharing.MemberSelector
        /// The new access level for member. owner in AccessLevel is disallowed.
        public let accessLevel : Sharing.AccessLevel
        public init(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.accessLevel = accessLevel
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdateFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .Null)
                    return UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UpdateFolderMemberError union
    */
    public enum UpdateFolderMemberError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            The target dropboxId in MemberSelector is invalid.
        */
        case InvalidDropboxId
        /**
            The target member in UpdateFolderMemberArg is not a member of the shared folder.
        */
        case NotAMember
        /**
            The current user's account doesn't support this action. An example of this is when downgrading a member from
            editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business plan.
        */
        case InsufficientPlan
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NotAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_a_member")
                    return .Dictionary(d)
                case .InsufficientPlan:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("insufficient_plan")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UpdateFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UpdateFolderMemberError.AccessError(v)
                        case "invalid_dropbox_id":
                            return UpdateFolderMemberError.InvalidDropboxId
                        case "not_a_member":
                            return UpdateFolderMemberError.NotAMember
                        case "insufficient_plan":
                            return UpdateFolderMemberError.InsufficientPlan
                        case "other":
                            return UpdateFolderMemberError.Other
                        default:
                            return UpdateFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RelinquishFolderMembershipArg struct
    */
    public class RelinquishFolderMembershipArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RelinquishFolderMembershipArgSerializer().serialize(self)))"
        }
    }
    public class RelinquishFolderMembershipArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFolderMembershipArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelinquishFolderMembershipArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    return RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RelinquishFolderMembershipError union
    */
    public enum RelinquishFolderMembershipError: CustomStringConvertible {
        case AccessError(Sharing.SharedFolderAccessError)
        /**
            The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
            folders. Try unsharing or transfering ownership first.
        */
        case FolderOwner
        /**
            The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
        */
        case Mounted
        /**
            The current user has access to the shared folder via a group.  You can't relinquish membership to folders
            shared via groups.
        */
        case GroupAccess
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RelinquishFolderMembershipErrorSerializer().serialize(self)))"
        }
    }
    public class RelinquishFolderMembershipErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFolderMembershipError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .FolderOwner:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder_owner")
                    return .Dictionary(d)
                case .Mounted:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("mounted")
                    return .Dictionary(d)
                case .GroupAccess:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("group_access")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RelinquishFolderMembershipError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RelinquishFolderMembershipError.AccessError(v)
                        case "folder_owner":
                            return RelinquishFolderMembershipError.FolderOwner
                        case "mounted":
                            return RelinquishFolderMembershipError.Mounted
                        case "group_access":
                            return RelinquishFolderMembershipError.GroupAccess
                        case "other":
                            return RelinquishFolderMembershipError.Other
                        default:
                            return RelinquishFolderMembershipError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
}
